/**
 * DecisionsYAMLGenerator - Generates decisions.yaml from wizard session data
 * This YAML file documents all critical project decisions made in the wizard
 */

import { WizardSession } from '@prisma/client';

export class DecisionsYAMLGenerator {
  generate(session: WizardSession): string {
    const lines: string[] = [];

    // Header
    lines.push('# Project Decision Record');
    lines.push('# Generated by Autonomous Project Builder v0.8');
    lines.push(`# Session ID: ${session.id}`);
    lines.push(`# Generated: ${new Date().toISOString()}`);
    lines.push('');

    // Project Basics
    lines.push('project:');
    lines.push(`  name: "${session.projectName || 'Unnamed Project'}"`);
    lines.push(`  type: ${session.projectType || 'unknown'}`);
    lines.push(`  description: |`);
    const descLines = (session.description || 'No description provided').split('\n');
    descLines.forEach(line => lines.push(`    ${line}`));
    lines.push(`  timeline: "${session.timeline || 'Not specified'}"`);
    lines.push(`  team_size: ${session.teamSize || 'unknown'}`);
    lines.push(`  budget_tier: ${session.budgetTier || 'not_specified'}`);
    lines.push('');

    // Non-Negotiables - CRITICAL
    lines.push('# CRITICAL: Non-Negotiable Decisions');
    lines.push('# These decisions are locked and cannot change without major rework');
    lines.push('non_negotiables:');

    if (session.nonNegotiables) {
      try {
        const nonNeg = JSON.parse(session.nonNegotiables);
        lines.push(`  end_to_end_encryption: ${nonNeg.e2ee !== undefined ? nonNeg.e2ee : 'undecided'}`);
        lines.push(`  admin_can_read_data: ${nonNeg.adminRead !== undefined ? nonNeg.adminRead : 'undecided'}`);
        lines.push(`  phone_number_identity: ${nonNeg.phoneIdentity !== undefined ? nonNeg.phoneIdentity : 'undecided'}`);
        lines.push(`  anonymous_users_allowed: ${nonNeg.anonymousUsers !== undefined ? nonNeg.anonymousUsers : 'undecided'}`);
        lines.push(`  multi_region_deployment: ${nonNeg.multiRegion !== undefined ? nonNeg.multiRegion : 'undecided'}`);
        lines.push(`  offline_first_architecture: ${nonNeg.offlineFirst !== undefined ? nonNeg.offlineFirst : 'undecided'}`);
        lines.push(`  multi_tenant_architecture: ${nonNeg.multiTenant !== undefined ? nonNeg.multiTenant : 'undecided'}`);
        lines.push(`  open_source_license: ${nonNeg.openSource !== undefined ? nonNeg.openSource : 'undecided'}`);
      } catch (e) {
        lines.push('  # Error parsing non-negotiables');
      }
    } else {
      lines.push('  # No non-negotiables defined');
    }
    lines.push('');

    // User Personas
    lines.push('personas:');
    if (session.personas) {
      try {
        const personas = JSON.parse(session.personas);
        if (Array.isArray(personas) && personas.length > 0) {
          personas.forEach((persona, idx) => {
            lines.push(`  - name: "${persona.name || `Persona ${idx + 1}`}"`);
            lines.push(`    role: "${persona.role || 'Not specified'}"`);
            if (persona.goals && persona.goals.length > 0) {
              lines.push(`    goals:`);
              persona.goals.forEach((goal: string) => {
                if (goal) lines.push(`      - "${goal}"`);
              });
            }
            if (persona.techSkill) lines.push(`    technical_skill: ${persona.techSkill}`);
            if (persona.frequency) lines.push(`    usage_frequency: ${persona.frequency}`);
          });
        } else {
          lines.push('  [] # No personas defined');
        }
      } catch (e) {
        lines.push('  [] # Error parsing personas');
      }
    } else {
      lines.push('  [] # No personas defined');
    }
    lines.push('');

    // Features & Scope
    lines.push('features:');
    lines.push('  mvp:');
    lines.push('  post_mvp:');
    lines.push('  nice_to_have:');

    if (session.features) {
      try {
        const features = JSON.parse(session.features);
        if (Array.isArray(features)) {
          const mvp = features.filter(f => f.scope === 'mvp');
          const postMvp = features.filter(f => f.scope === 'post-mvp');
          const nice = features.filter(f => f.scope === 'nice');

          if (mvp.length > 0) {
            lines[lines.length - 3] = '  mvp:';
            mvp.forEach(f => {
              lines.push(`    - name: "${f.name}"`);
              if (f.description) lines.push(`      description: "${f.description}"`);
              lines.push(`      priority: ${f.priority}`);
            });
          }

          if (postMvp.length > 0) {
            lines[lines.length - 2] = '  post_mvp:';
            postMvp.forEach(f => {
              lines.push(`    - name: "${f.name}"`);
              if (f.description) lines.push(`      description: "${f.description}"`);
              lines.push(`      priority: ${f.priority}`);
            });
          }

          if (nice.length > 0) {
            lines[lines.length - 1] = '  nice_to_have:';
            nice.forEach(f => {
              lines.push(`    - name: "${f.name}"`);
              if (f.description) lines.push(`      description: "${f.description}"`);
              lines.push(`      priority: ${f.priority}`);
            });
          }
        }
      } catch (e) {
        // Keep empty arrays
      }
    }
    lines.push('');

    // Scope
    lines.push('scope:');
    lines.push('  in_scope:');
    if (session.inScope) {
      try {
        const inScope = JSON.parse(session.inScope);
        if (Array.isArray(inScope) && inScope.length > 0) {
          inScope.forEach(item => {
            if (item) lines.push(`    - "${item}"`);
          });
        } else {
          lines.push('    [] # Not defined');
        }
      } catch (e) {
        lines.push('    [] # Error parsing');
      }
    } else {
      lines.push('    [] # Not defined');
    }

    lines.push('  out_of_scope:');
    if (session.outOfScope) {
      try {
        const outOfScope = JSON.parse(session.outOfScope);
        if (Array.isArray(outOfScope) && outOfScope.length > 0) {
          outOfScope.forEach(item => {
            if (item) lines.push(`    - "${item}"`);
          });
        } else {
          lines.push('    [] # Not defined');
        }
      } catch (e) {
        lines.push('    [] # Error parsing');
      }
    } else {
      lines.push('    [] # Not defined');
    }
    lines.push('');

    // Technical Stack
    lines.push('technical_stack:');
    if (session.techStack) {
      try {
        const tech = JSON.parse(session.techStack);
        lines.push(`  backend: "${tech.backend || 'auto-recommend'}"`);
        lines.push(`  frontend: "${tech.frontend || 'auto-recommend'}"`);
        lines.push(`  database: "${tech.database || 'auto-recommend'}"`);
        lines.push(`  hosting: "${tech.hosting || 'auto-recommend'}"`);
      } catch (e) {
        lines.push('  # Error parsing tech stack');
      }
    } else {
      lines.push('  backend: "auto-recommend"');
      lines.push('  frontend: "auto-recommend"');
      lines.push('  database: "auto-recommend"');
      lines.push('  hosting: "auto-recommend"');
    }
    lines.push('');

    // Performance Requirements
    lines.push('performance:');
    if (session.performanceReqs) {
      try {
        const perf = JSON.parse(session.performanceReqs);
        if (perf.pageLoad) lines.push(`  page_load_target_seconds: ${perf.pageLoad}`);
        if (perf.apiResponse) lines.push(`  api_response_target_ms: ${perf.apiResponse}`);
      } catch (e) {
        lines.push('  # Error parsing performance requirements');
      }
    } else {
      lines.push('  # Not specified');
    }
    lines.push('');

    // Security
    lines.push('security:');
    if (session.securityReqs) {
      try {
        const sec = JSON.parse(session.securityReqs);
        if (sec.authMethod) lines.push(`  authentication: "${sec.authMethod}"`);
        if (sec.encryption && Array.isArray(sec.encryption)) {
          lines.push(`  encryption:`);
          sec.encryption.forEach((e: string) => lines.push(`    - ${e}`));
        }
        if (sec.compliance && Array.isArray(sec.compliance)) {
          lines.push(`  compliance:`);
          sec.compliance.forEach((c: string) => lines.push(`    - ${c}`));
        }
      } catch (e) {
        lines.push('  # Error parsing security requirements');
      }
    } else {
      lines.push('  # Not specified');
    }
    lines.push('');

    // Scalability
    lines.push('scalability:');
    if (session.scalabilityReqs) {
      try {
        const scale = JSON.parse(session.scalabilityReqs);
        if (scale.expectedUsers) lines.push(`  expected_concurrent_users: ${scale.expectedUsers}`);
        if (scale.peakLoad) lines.push(`  peak_requests_per_second: ${scale.peakLoad}`);
        if (scale.dataVolume) lines.push(`  data_volume: "${scale.dataVolume}"`);
      } catch (e) {
        lines.push('  # Error parsing scalability requirements');
      }
    } else {
      lines.push('  # Not specified');
    }
    lines.push('');

    // Accessibility
    if (session.accessibilityReq) {
      lines.push(`accessibility: WCAG_${session.accessibilityReq}`);
      lines.push('');
    }

    // Data Model
    lines.push('data_model:');
    if (session.dataModel) {
      try {
        const dataModel = JSON.parse(session.dataModel);
        if (Array.isArray(dataModel) && dataModel.length > 0) {
          dataModel.forEach(entity => {
            if (entity.entity) {
              lines.push(`  - entity: "${entity.entity}"`);
              if (entity.fields && Array.isArray(entity.fields)) {
                lines.push(`    fields:`);
                entity.fields.forEach((field: string) => {
                  if (field) lines.push(`      - ${field}`);
                });
              }
              if (entity.relationships && Array.isArray(entity.relationships)) {
                lines.push(`    relationships:`);
                entity.relationships.forEach((rel: string) => {
                  if (rel) lines.push(`      - "${rel}"`);
                });
              }
            }
          });
        } else {
          lines.push('  [] # No data model defined');
        }
      } catch (e) {
        lines.push('  [] # Error parsing data model');
      }
    } else {
      lines.push('  [] # No data model defined');
    }
    lines.push('');

    // External APIs
    lines.push('external_apis:');
    if (session.externalAPIs) {
      try {
        const apis = JSON.parse(session.externalAPIs);
        if (Array.isArray(apis) && apis.length > 0) {
          apis.forEach(api => {
            if (api.name) {
              lines.push(`  - name: "${api.name}"`);
              if (api.purpose) lines.push(`    purpose: "${api.purpose}"`);
              if (api.criticality) lines.push(`    criticality: ${api.criticality}`);
            }
          });
        } else {
          lines.push('  [] # No external APIs');
        }
      } catch (e) {
        lines.push('  [] # Error parsing external APIs');
      }
    } else {
      lines.push('  [] # No external APIs');
    }
    lines.push('');

    // Data Privacy
    lines.push('data_privacy:');
    if (session.dataPrivacy) {
      try {
        const privacy = JSON.parse(session.dataPrivacy);
        if (privacy.gdpr) lines.push(`  gdpr_compliance: true`);
        if (privacy.hipaa) lines.push(`  hipaa_compliance: true`);
        if (privacy.ccpa) lines.push(`  ccpa_compliance: true`);
        if (privacy.retention) lines.push(`  data_retention: "${privacy.retention}"`);
        if (privacy.backups) lines.push(`  automated_backups: true`);
        if (privacy.disasterRecovery) lines.push(`  disaster_recovery_plan: required`);
      } catch (e) {
        lines.push('  # Error parsing data privacy');
      }
    } else {
      lines.push('  # Not specified');
    }
    lines.push('');

    // Metadata
    lines.push('metadata:');
    lines.push(`  created_at: "${session.createdAt.toISOString()}"`);
    lines.push(`  updated_at: "${session.updatedAt.toISOString()}"`);
    lines.push(`  completeness_score: ${session.completenessScore}`);
    lines.push(`  status: ${session.status}`);

    return lines.join('\n');
  }
}
